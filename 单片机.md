# 单片机

板子型号：STC15F2K60S2

其实对与主芯片来说有有控制端和输出端

​	控制端：常常对于独立按键和矩阵按键来说，直接通过传入电位的变化来判断按键是否被按下，进而给主芯片传入信息。（一般是通过判断语句进行判断的）

​	输出端：根据控制端传入的信息给LED，数码管传递电位。（一般是通过程序进行直接设置的）

## 一些常用的数组

uchar 	NUMBER[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
ucahr 	ADDRESS[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};

## LED灯 Y4

- 138板   输入接口为P2系列

位选

如：Y4  110

P2 |=((1<<7)|(1<<6));

P2 &=~((1<<5));

- 573板  输入接口为P0系列

段选

如：输入0(低电位)灯亮

第一个灯亮 为1111  1110   =0xFE

+ 时间延迟

delay_ms(int ms){

​	for(int i=0;i<ms;i++)

​	for(int j=846;j>0;j++)

}

## 数码管  Y6  Y7

位选

如上：Y6  110 

P2 |=((1<<7)|(1<<6))

P2 &=~(1<<5)

 Y7 111

  P2 |=((1<<7)|(1<<6)|(1<<5))

+ 数码管的静态和动态

静态：全部显示的为一个数字，没有延迟

动态：可以显示多个不同的数字，必须要有延迟

## 孤立按键

判断

S6=0;

if(P30==0&&S6==0)

{

​	delay(5);//消抖

​	S6=1;

}

if(P30==1&&S6=1)

{

​	figure++;

}

## 矩阵按键

对应的接口和独立按键有相同的部分

P30 P31 P32 P33 P34 P35 P36(P42) P37(P44)

其中P36和P37分别用P42和P44代替；但赋值时可以 P44=1;P42=0;P3=0xbf;的方法进行赋值。

void KeyScan()
{
	int temp=0;
	P44=0;P42=1;
	P3=0x7f;
	temp=P3&0x0f;
	if(temp!=0x0f)
	{
		delay_ms(5);
		switch(P3)
		{
			case 0x7e:a+=1;break;
			case 0x7d:a+=4;break;
			case 0x7b:a+=7;break;
			case 0x77:a+=0;break;
		}
	}

do{
				temp=P3&0x0f;
		}while(temp!=0x0f);

}

矩阵按键设置不能像独立按键一样

## 外部中断

IT0=1//只有下降沿触发

IT=0//上升沿或者下降沿都能触发

EX0=1//选择是什么中断  终端号要与interrupt号对应

EA=1//总开关

//外部中断初始化

void INT0_Init()  //中断初始化需要在主函数中调用

{

​	IT0=1;

EX0=1;

EA=1;

}

//外部中断服务程序

void INT0_return()  interrupt 0

//带有interrupt关键字的不用在主函数中调用，而是直接可以由系统的硬件调用。

{

a++;

}

[(37条消息) 51单片机中断详解（上）_Line-CSDN博客_51单片机中断请求标志](https://blog.csdn.net/u013151320/article/details/49977813?spm=1001.2014.3001.5501)

## 定时器中断

（1）中断允许控制寄存器(IE)--------控制各中断的开放和屏蔽

（2）定时器/计数器控制寄存器(TCON)-------定时器和外部中断的控制

（3）串行口控制寄存器(SCON)-------串行中断的控制

（4）中断优先级控制寄存器(IP)-------设置各中断的优先级

![img](https://img-blog.csdn.net/20170224224833755)



从上图可看出从中断源产生请求到请求进入CPU的过程：

以INT0为例，INT0产生中断源，经过TCON寄存器中的IT0为选择是下边沿触发的还是低电平触发的中断请求（当然IT0是程序人工设置的），当中断请求到达IE0的时候，IE0会被硬件置1（当CPU响应此中断请求时，IE0被硬件置0），然后就到 IE寄存器的地方了，EX0是外部中断INT0的开关，而 EA 是所有中断的总开关，这都由 IE寄存器

控制，最后经过 IP寄存器 设置优先级，这个一般比较少用，默认的优先级为，INT0 > T0 > INT1 > T1 >串口中断。最后把中断请求传给CPU。





void Timer0Init()
{
	TMOD=0X01;//TMOD寄存器   16bit运算
	TH0=(65536-50000)/256;
	TL0=(65536-50000)%256;
	TR0=1;//TCON寄存器控制的开关
	ET0=1;//IE寄存器控制的开关
	EA=1;//总开关
}
void Timer0_return() interrupt 1
{
	TR0=0;
	TH0=(65536-50000)/256;
	TL0=(65536-50000)%256;
	num++;
	if(num==20)
	{
		num=0;
		flag++;
	}
	TR0=1;
}

## 计数器

[(37条消息) 学习笔记之-51单片机定时计数器_gjxman1314的博客-CSDN博客_单片机计数器计数程序](https://blog.csdn.net/gjxman1314/article/details/54989161?ops_request_misc=%7B%22request%5Fid%22%3A%22164039391516780271920371%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164039391516780271920371&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-54989161.first_rank_v2_pc_rank_v29&utm_term=单片机计数器&spm=1018.2226.3001.4187)

## 串口通信

### 接收数据

void UartInit(void)		//9600bps@11.0592MHz
{
	SCON = 0x50;		//8位数据,可变波特率
	AUXR |= 0x40;		//定时器1时钟为Fosc,即1T
	AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0F;		//设定定时器1为16位自动重装方式
	TL1 = 0xE0;		//设定定时初值
	TH1 = 0xFE;		//设定定时初值
	ET1 = 0;		//禁止定时器1中断

​	EA=1;

​	ES=1;//串口中断开关

​	TR1 = 1;		//启动定时器1
}

void Uart_RI() interrupt 4
{
	if(RI)
	{
		RI=0;//RI为SCON寄存器中的的一个位，当RI=0时说明可以进行接收数据，当RI=1时说明已经接收到数据

//接收到的数据存在SBUF中，可以直接进行调用。

​		//P4 100
​		P2 |=(1<<7);
​		P2 &=~((1<<6)|(1<<5));
​		P0=SBUF;
​		
​	}
}

### 数据传输

void Sent_byte(char a)
{
	SBUF=a;
	while(!TI);
	IT=0;
}

## 温度传感器（DS18B20）



**1**，
（1）初始化
（2）发送ROM命令–SKIP ROM(0xcc   0x44)
（3）发送功能命令–温度转换
**2**，
（1）初始化
（2）发送ROM命令–SKIP ROM(0xcc    0xbe)
（3）发送功能命令–读取暂存器
（4）读暂存器（ds18b20在收到读暂存器功能命令后先发送低位，再发送高位）



init_ds18b20();		//初始化
		Write_DS18B20(0xcc);	//跳过rom
		Write_DS18B20(0x44); 	//发送温度转换命令

		init_ds18b20();		//初始化
		Write_DS18B20(0xcc);	//跳过ROM
		Write_DS18B20(0xbe);	//发送读暂存器命令
		low=Read_DS18B20();   	//先读低位
	    high=Read_DS18B20();	//再度高位
		high=high<<4;
		low=low>>4;
		temp=high|low;		
		return temp;		//返回的temp为一个二进制8位的数，不是十进制的数

## 时钟芯片

